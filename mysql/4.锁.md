# 锁

# 4.1 什么是锁

  实现数据一致性的手段。
  
  不同数据库有不同的实现方式，MuISAM支持表锁，InnoDB支持行锁。
  
# 4.2 InnoDB的锁

### 4.2.1 锁的类型

  * 共享锁
  
  * 排他锁
  
### 4.2.2 自增与锁

  为了提高插入性能，自增的锁不是在一个事务完成后释放，而是在实现对自增长值插入的SQL语句后立即释放。
  
  但仍然在并发执行上性能差。
  
  自增必须是索引，并且必须是索引的第一个列。
  
### 4.2.2 并发的问题

  * 脏读：A在写的时候，B访问了数据，因为这个数据是没有提交的数据，所有产生了错误的结果。

  * 不可重复读：在同一事务内多次读取数据，其他事物提交了数据，读到的结果不一致。
  
  * 幻读：A在读取的时候，B插入了几行数据，A读到了原来不存在的数据。 
  
# 4.3 表锁和行锁

InnoDB支持表锁和行锁，MyISAM只支持表锁。但是，InnoDB只有通过索引检索才会使用行锁。

* 表级锁：MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。

* 行级锁：MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。
  
InnoDB支持的行级锁有：

* Record Lock：对索引项加锁，锁定符合条件的行。其他事务不能修改和删除。

* Gap Lock：对查找到的数据之间的区间进行加锁，锁定区间范围但是不包括数据本身，可以防止插入。

* Next-Key Lock：Gap Lock和RecordLock的结合。

虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的：

* 事务更新大表中的大部分数据直接使用表级锁效率更高。

* 事务比较复杂，使用行级索很可能引起死锁导致回滚。

# 4.4 InnoDB对于锁的应用

* innodb对于行的查询使用next-key lock

* Next-locking keying为了解决Phantom Problem幻读问题

* 当查询的索引含有唯一属性时，将next-key lock降级为record key

* Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生

* 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1


  