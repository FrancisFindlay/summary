# Java内存和内存溢出异常

# 2.1 概述

  Java由Jvm进行内存管理，不需要程序员进行。
  
# 2.2 运行时数据区域

  Java运行数据区可以分为如下
  
### 2.2.1 PC
  PC是当前线程所执行字节码的行号指示器，通过改变PC的值来选取下一个需要执行的指令。为了多线程环境，每个线程都需要有一个PC，PC是线程私有的。
  
  如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的字节码指令的地址；如果执行Native方法，PC为空。
  
### 2.2.2 Java虚拟机栈
  同样，Java虚拟机栈也是线程私有，生命周期和线程相同。每个Java方法被执行，Jvm都会为其创造一个栈帧存储局部变量表，操作数，方法出口等信息。
  一个方法被调用到执行完，就是一个栈帧从虚拟机入栈到出栈的过程。
  
  上面提到的局部变量表中存放八大基本数据类型，对象引用类型。这些类型在存储空间以Slot来表示，64位的long和double用两个槽占用，其他的只占
  用一个。当进入一个方法，这个方法需要在栈帧分配的大小是完全确定的，在运行期间不会改变局部变量表中槽的数量。
  
  这里会出现StackOverFlow和OutOfMemory两种错误，一种是栈深度超过Jvm允许的深度，另外一种是当栈容量可以动态扩展时无法申请足够的内存。
  
  Java虚拟机栈可以通过 -Xss128K 来设置其大小。
  
### 2.2.3 本地方法栈
  为Native方法服务。

### 2.2.4 Java堆
  堆在Jvm启动时创建，所有对象以及数组都应当在这里分配内存空间。  
  
  堆可以在不连续的物理内存空间上，但在逻辑上应该是连续的。
  
### 2.2.5 方法区
  JDK8移除了永久代，改用元数据区实现方法区，将原来在永久代的字符串常量池，静态变量等移除，剩下的关于类型信息的内容移到元数据区。
  
  Class对象，静态变量，都移到了堆中。

  方法区还包括运行时常量池。JDK7开始，将常量池移到了堆中。Class文件除了有类的版本，字段，方法以及接口等描述信息外，还有一项就是常量池，用来存放表一起生成的各种字面常
  量和符号引用。运行期间也可以将新的常量放入常量池，比如string的intern（）方法。
### 2.2.6 直接内存

  直接内存不是运行时数据区的一部分，也不是Jvm规定的内存区域，而是受本地内存的约束。
  
  NIO引入的一种基于Channel和Buffer的IO，可以使用Native方法直接分配堆外内存，然后通过一个存储在堆里的ByteBuffer对象作为这块内存的引用
  操作这块内存。
  
# 2.3 对象的创建

  1.当Jvm遇到一条new指令时，首先检查这个类是否能在常量池定位到，并且检查这个类是否被加载，解析和初始化过。
  
  2.之后，就为新生对象分配内存。对象所需内存的大小在第一步就可以确定。对象的分配内存有两种方法：
    
  * 指针碰撞：如果堆中内存规整，那么就把指针向空闲区域移动等大的距离。
  
  * 空闲列表：若堆中内困不规整，就必须让虚拟机维护一个列表记录哪些内存是可用的，然后从可用空间分配内存。
  
  具体使用哪种方法分配取决于堆的内存是否规整，而这又取决于采用哪种垃圾回收器。当采用Serial，ParNew等标记整理算法实现的时，采用指针碰撞，
  但如果是CMS这种基于垃圾清理的回收器，就必须维护空闲列表。
  
  对于指针碰撞在并发期间遇到的问题，通常采用CAS算法保证操作的原子性。
  
  3.当分配内存后，就必须初始化对象了。虚拟机将分配的内存区域都赋予零值。
  
  4.之后，还需要对对象进行必要的设置，例如这个对象是哪个类的实例，如何找到元数据区，对象的hash码，GC年龄等，Jvm将这些信息存放在对象头。
  
  5.之后，就需要执行构造函数了。这时，一个对象就被创建出来。
  
### 2.3.1 对象的内存布局
  
  * 对象头
  
  * 实例数据
  
  * 对齐填充
  
# 2.3.2 对象的访问定位
  * 句柄访问：若采用句柄访问，heap中就需要一块内存来作为句柄池，引用就存放对象的句柄地址，句柄存放对象各类信息的地址。
  
  * 直接指针访问：如果采用直接指针，就必须考虑如何放置访问类型数据的相关信息，引用存放对象地址。
  
  使用句柄访问最大的好处是对象移动时，不需要改变引用的值。
  
  使用直接指针访问最大的好处是速度快，节省了一次指针定位的时间。HotSpot主要采用直接指针访问。
  
# 2.4 OutOfMemory 异常
  
### 2.4.1 堆溢出
  
      min size:-Xms<heap size>[unit]
      max size:-Xmx<heap size>[unit]
      
      unit:具体单位 G,M,K
      heap size:具体大小
      
  要解决heap的内存异常，常规方法就是通过内存映射工具堆Dump出来的快照进行分析。首先确定是内存泄漏还是内存溢出。
  
  如果是内存泄漏，可以通过泄漏对象到GC roots的引用链，找到对象通过怎样的引用路径，与哪些gc roots关联，导致无法回收。
  
  如果是内存溢出，可以通过改变堆的大小进行解决。
  
### 2.4.2 Jvm栈和本地方法栈的溢出

  HotSpot不区分虚拟机栈和本地栈，因此，只能通过-Xss 来指定大小。
  
  两种错误
   
  * 栈深度大于最大深度
  
  * 栈无法申请到足够内存
  
### 2.4.3 方法区和运行时常量池溢出

  String.intern()是一个本地方法，作用是如果常量池包含一个等于String对象的字符串，则返回代表池中这个字符串的对象的引用，否则，就将新的
  字符串加入到常量池。 
  
  对于常量池出错，根据JDK的不同，对常量池所在区域的内存大小调整解决。
  
### 2.4.4 直接内存出错
    
  直接内存可以用 -XX：MaxDIrectMemorySize 来指定。
  
  如果不显示指定，默认和Java堆的大小一致。直接内存的分配通过unsafe的allocatemememory()来实现。      
  

    
    