# 类加载时机

# 7.1 类加载的时机

  * 加载
  
  * 验证
  
  * 准备
  
  * 解析
  
  * 初始化
  
  * 使用
  
  * 卸载
  
### 7.1.1 加载

  在加载的阶段，Jvm需要完成三个事情：
  
  * 通过全限定名获得类的.class文件。
    
  * 将.class文件所代表的静态存储结构转化为方法区的运行时数据结构。
  
  * 在内存中生成一个Class对象，作为这个类的访问入口。
    
### 7.1.2 验证    
  确保class文件符合Java规范，防止恶意代码侵入。
  
  在这个阶段大概有四个动作：
  * 文件格式验证：确保字节流符合class文件格式。
  
    * 是否以魔术0xCAFEBABE开头
    
    * 主、次版本号是否在当前Java虚拟机接受范围
    
    * 常量中是否有不被支持的类型，以及指向常量的各种索引值是否有不存在的常量等
    
  * 元数据验证：进行语义分析，保证符合Java要求。
  
    * 这个类是否有父类
    
    * 父类是否继承了不该继承的类
    
  * 字节码验证
  确保语义的合法性，流程的正确性。
  
  * 符号引用验证
    * 根据类的全限定名是否能找到类
    * 符号引用的字段，方法的可访问性    
    
### 7.1.3 准备
  准备阶段为类变量分配内存并且设置类变量初始值，分配在堆空间中。
### 7.1.4 解析  

  解析阶段是Java将常量池的符号以及字段和方法的引用替换为直接引用的过程。
  
  * 类或者接口的解析：对于常量池中类D的符号引用N转换为类C，要转换为直接引用有三个步骤：
  
     * 如果类是一个非数组型类型，虚拟机会把符号引用N的全限定名传递给类D的类加载器加载C。
     
     * 如果类是一个数组类型，首先加载对应的数组元素的类型（上），之后，虚拟机生成一个代表该数组维度和元素的数组对象。
     
     * 上面不出现问题，那么C在虚拟机就已经有效了，但仍然还要进行验证过程，确认D有对C的访问权限。
     
  * 字段解析：先解析该字段所在的类或者接口引用。然后在该类中查找是否有和目标匹配的字段，如果没有，接着查找类的父类和接口，继续查找。若一
  直查找不到，那么就返回NosuchFieldError(根据双亲委派模型进行查找)。   
  
  * 类方法解析：仍然需要解析所在类或者接口的符号引用。由于接口和类的符号索引在常量池是分开定义的，因此，如果C是接口，报错。之后，根据上述
  的查找方式一直查找父类。
  
  * 接口方法解析：和上述过程类似。
  
### 7.1.5 初始化
  初始化阶段就是执行类构造器<clinit>（）的过程，这时javac编译生成的产物，负责收集所有类变量的赋值动作以及静态代码块的动作，这个阶段，
  首先是静态变量的声明，其次才是静态代码块，因此，应该注意二者的读取和写入规则。  
      
  另外，jvm保证父类的<clinit>（）会得到执行。接口不同的是，只有当使用到父类时，才会调用父类的<CLINIT>()。
  
  jvm保证<CLINIT>()是线程安全的。
  
# 7.2 类加载器
  对于一个类，都必须由加载它的类加载器和这个类本身一起共同确定唯一性，每一个类加载器，都有一个独立的命名空间。同一个class文件，通过不同
  的类加载器加载出来，仍然不是同一个类。

# 7.3 双亲委派模型
  从Java虚拟机的角度看，只存在两个不同的类加载器：一是启动类加载器bootstrap classloader，这个加载器由cpp实现。另外一个是其他所有的加载器，   
  这些加载器都由Java实现。独立存在于虚拟机，全都继承于java.LANG.CLASSLOADER。
  
  * bootstrap类加载器：加载JAVA_HOME/LIB目录的类。
  
  * extension类加载器：加载Java_HOME/lib/ext的类，允许用户拓展java类库。
  
  * application类加载器：加载用户路径的所有类库。
  
  双亲委派模型的工作流程：一个类加载器收到加载请求，会首先交给上层类加载器加载，依次。这样保证了类的唯一性，以及Object是所有父类这一条件。