# Java中的锁

# 5.1 Lock 接口

  Lock接口提供的区别于同步的特性：
  
  * 非阻塞获取锁
  
  * 能被中断的获取
  
  * 超时获取
  
  trylock():非阻塞获取
  
  tryLock(Long time,TimeUnit unit):超时获取
  
# 5.2 AQS
  同步器的状态根据三个方法来获取：
  
  * getState()
  
  * setState()
  
  * compareAndSetState()：CAS
  
  同步器可以重写的方法：
  
  * tryAcquire（int arg）：独占获取同步状态，然后设置同步状态
  
  * tryRelease（int arg）：独占释放同步状态
  
  * tryAcquireShared（int arg）：共享获取，返回大于等于0的值表示获取成功，反之失败
  
  * tryReleaseShared(int arg)
  
  实现自定义控件会用到的模板方法：
  
  * void acquire（int arg）：独占获取，获取成功就返回；否则，进入同步队列；该方法会调用tryAcquire。
  
  * void acquireShared（）：共享获取
  
  同步队列：
    同步器用一个双向队列管理同步队列，当前线程获取失败，同步器会将当前线程和等待状态等信息构造为一个节点，加入同步队列，并且阻塞当前线程。当
    同步状态释放，会把第二个节点唤醒，使其尝试进入。
    
   在对队列的出入操作时，必须保证线程安全。同步器基于CAS实现了compareAndSetTail（）来进行入队操作。
   同步队列的首节点是获取同步状态成功的节点，其线程为null。首节点的线程执行完后，后继节点就将自己设置为首节点，并将内部线程交由执行。
   
   
   
### 5.2.1 独占式获取
  首先调用tryAcquire（）尝试获取同步状态，如果获取失败，构造同步节点（同一时刻只会有一个线程成功构造），并且通过addWaiter（）加入到同步
  队列的尾部，最后调用acquireQueued（）使其自旋，一直尝试加入到队列中，通过这种方式，实现了入队的串行化。
  
  节点加入到队列后，就进入了一个自旋的过程。每个节点都在自己观察，当条件满足，获取到了同步状态，就可以停止自旋，否则一直自旋，并阻塞当前线程。
  
  队列中的节点自旋时，只有当前驱节点是头节点才能获得同步状态。
  
  当前线程获取同步状态并执行完毕后，需要通过release（）释放同步状态，通知后继进行获取。
  
### 5.2.2 共享式获取
  通过调用acquireShared（）可以共享式获取。acquireShared（）通过调用tryAcquireShared（），这个方法的返回值是int，当返回值大于等于0，
  表示能够获取到。因此，共享式获取的自旋过程中，成功获取到同步状态并且退出自旋的条件是返回值大于等于0。如果获取失败，也就是返回值小于0，那么就会
  执行doAcquireShared（），在这个方法中，如果前置节点为头节点，才会再次尝试获取。
  
### 5.2.3 独占超时获取

# 5.3 重入锁
  支持重进入的锁，表示该锁能够支持一个线程对资源的重复加锁。支持公平锁和非公平锁两种。
  
  同步代码块是隐式支持重入的，ReentrantLock同样，对于已经获取到锁的线程，可以再次获得锁。
  
  公平锁和非公平锁：如果能保证等待最长时间的任务先被满足，那么就是公平锁，否则，是非公平锁。公平锁可以解决饥饿问题，但是效率没有非公平锁高。
  
  ReentrantLock通过默认为非公平锁来实现重入，当线程再次获取锁，首先去识别是否是当前线程，然后，对于n次重复进入的锁，计数器自增。而当锁被
  释放后，计数器自减。非公平锁只要tryAcquire（）设置同步状态成功，就可以获得锁。而公平锁，必须判断是否前驱节点为头，否则，就必须等待。
  
# 5.4 读写锁
  之前的Mutex和ReentrantLock都是排他锁，在同一时刻值允许一个线程进行访问。而读写锁可以允许多个读线程访问，但在写线程的处理，同样只能允许一个
  线程访问。读写锁维护了一个写锁和一个读锁。
  
### 5.4.1 写锁的获取和释放

写锁是支持重入的排他锁。如果当前线程已经获取了写锁，就增加写状态。如果当前线程在获取写锁时，读锁被获取或者该线程不是已经获得了写锁的线程，那当前线程就会等待。如果存在读锁，写锁就不能被获取。

### 5.4.2 读锁的获取和释放

读锁是支持重入的共享锁，能被多个线程同时获取。在没有其他写线程访问时，读锁总是被成功的获取。如果在获取读锁时，写锁已经被获取，那么当前线程就进入等待状态。

### 5.4.3 读写锁状态的统计
  
  读写锁在一个volatile变量上维护了多个读进程和一个写进程的状态。 **用高十六位表示读** ，**低十六位表示写**。
  
### 5.4.4 锁降级  
  
  考虑，当一个写锁释放后，才获取读锁，这个过程中如果有另外的写锁，那么就不能保证可见性。

  所谓锁降级就是，当读锁尝试获取时写锁已经被获取，写锁不会直接释放，而是先把持住，然后获取读锁，再释放写锁的过程就是锁降级。这保证了下一次的写锁不会非公平的抢占。
  
# 5.5 LockSupport

  实现了park（）方法，阻塞当前线程，如果调用unpark（）或者当前线程被中断，就从park（）返回。
  
# 5.6 Condition
  wait（）和notify（）都必须和同步代码块配合使用。为了实现同样的功能，Java提供了更强大的Condition。  
  
  Condition提供了await（）和signal（）两个方法。condition对象是AQS的内部类，每个condition都包括一个等待队列。
  
  等待队列：如果一个线程调用了await（），那么线程将会释放锁，构造为节点加入等待队列并进入等待状态。等待队列的添加并没有实现AQS，原因是调用await（）
  的线程必定是获得了锁的线程。
  
  在Object的监视器模型上，一个对象拥有一个同步队列和一个等待1队列。而Lock拥有一个同步队列和多个等待队列。
  
  调用await（）的线程，是从同步队列的头移动到了condition的等待队列中，调用了LockSupport的park（）。
  
  调用signal（），将会唤醒等待队列中等待时间最长，也就是队头。调用该方法的线程必须是获得了锁的线程，接着获取头节点，然后加入到同步队列，使用
  LockSupport进行唤醒。            
  
    
    