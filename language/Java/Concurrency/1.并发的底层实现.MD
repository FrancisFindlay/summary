# 并发编程的底层实现原理

# 2.1 volatile的应用
  有volatile修饰的变量，其字段表中会有volatile的标志。在汇编级别上，会有 **lock** 来修饰汇编级别的操作。
  
  lock前缀的指令会发生两件事
  
  * 当前处理器的缓存行立即写入内存
  
  * 其他处理器关于该变量的缓存行变为无效
  
  volatile在JMM中的语义由happens-before可以得到，对于一个volatile的读，一定可以看到上次对volatile的写。这可以实现：
  
  * 可见性
  
  * 原子性：对任何单个volatile变量的读写具有原子性，即使是long和double，而对于volatile++，则没有原子性。
  
  volatile的语义可以实现：
  
  * 读时，JMM会把当前线程的工作内存置为无效，必须从主内存读
  
  * 写时，所有前面的普通写已经对任何处理器可见。
  
# 2.2 synchronized的实现
  JavaSE在JDK1.6对其进行了优化，使其由原来的重量级锁变得相对轻量级，由Jvm层面进行了实现替代了操作系统级别实现。
  
  * 对于普通方法，synchronized修饰的是当前对象
  
  * 对于同步代码块，修饰括号内对象
  
  * 对于静态方法，修饰Class对象
  
  monitorenter指令在编译后插入到同步区的开始，monitorexit插入在结束点或者异常点，保证了enter一定和一个exit对应。每一对enter和exit，
  都是对Monitor对象的进入和退出。


### 2.2.1 synchronized的锁升级

线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord），然后使用CAS把对象头中的内容替换为线程1存储的锁记录（DisplacedMarkWord）的地址；

如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁。

但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，如果自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。

# 3.3 Java如何实现原子性操作
  * 通过加锁
  
  * CAS:
  ![cas](https://user-gold-cdn.xitu.io/2019/9/3/16cf74dbfb0b7acf?imageslim)
            
    CAS存在的问题：
  
    * ABA问题：加版本号解决
            一个线程将A改为B，另一个又改为A。C没有读取到A变为B的结果。
    
    * 循环开销时间大，CAS需要不断自旋来读取最新的内存值
           
    * 只能保证对一个共享变量的原子操作 
               
    * 自旋锁：如果没有获得锁资源，那么就一直循环等待。
    
# 3.4 Java内存模型
  Java的并发采用共享内存实现。所有的类，实例，数组等都存储在堆中，堆对线程是共享的，因此，就需要解决共享资源的问题。
  
  Java线程之间的通信通过JMM（Java内存模型）来实现，JMM决定共享变量的写入是否对另一个线程可见。
  
  线程之间的共享变量存储在主内存，每个线程都有一个工作内存，工作内存存储了变量的副本，这个工作内存是一个逻辑上的抽象，实际上是缓存，寄存器等。
  
  两个线程A和B如果要通信，必须经历两个步骤：
  
  * A把工作内存更新的变量刷新到主内存
  
  * B在主内存去读取需要的变量
  
  通过这样的设计，JMM容易实现CAS来实现免锁算法。
  
# 3.5 happens-before规则
  JMM用来解决有序性的规则，表明了两个操作A和B，A操作在B之前，对于具有A操作的结果对B可见的关系这种特性就是happens-before。

  下面是一些常见的happens-before：
  
  * 程序顺序规则：一个线程内的每个操作，happens-before于该线程的任意后续操作。
  
  * 监视器锁规则：一个锁的解锁，happens-before于随后对这个锁的加锁。
  
  * volatile规则：对一个volatile变量的写一定先于后面对这个变量的读
  
# 3.6 锁的JMM语义

  JMM保证了：
  
  * 线程释放锁时，JMM把所有该线程对应的本地内存中的共享变量刷新到主内存
  
  * 线程得到锁，JMM把所有工作内存的数据置为无效
  
  
  
  
# 3.7 ReentrantLock
  在ReentrantLock中，可以实现公平锁和非公平锁两种，默认为非公平锁。具体实现依赖于AQS，AQS使用一个state维护同步状态。
  
  
    
    
  
  