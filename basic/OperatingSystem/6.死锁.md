# 死锁

# 7.1 死锁发生的必要条件

 * 互斥：至少有一个资源处于非共享状态。

 * 占有等待：一个进程至少应该占有一个资源，并且等待另外一个资源。
 
 * 非抢占：资源不能被抢占。
 
 * 循环等待：存在循环等待。
# 7.2 资源分配图
 
   资源分配图是一种描述死锁的方法。Pi表示进程，Ri表示资源。Pi->Rj表示申请边，Rj->Pi表示分配边。资源中的点表示资源数量。
   
   进程与资源的关系可以通过分配图来描述，可以证明，如果分配图不成环，就不会出现死锁。如果出环，可能存在死锁。
   
   如果每个资源刚有有一个实例，有环意味着死锁。如果有多个实例，死锁的出现只是必要不充分条件。

# 7.3 死锁的处理方式
  * 允许系统进入死锁，并且声明死锁恢复机制。
  
  * 忽视问题，认为死锁不可能发生。
  
# 7.4 死锁避免

### 7.4.1 破坏死锁的四个必要条件的任何一个

### 7.4.2 安全状态
  所谓系统是安全的，是指系统中的所有进程能够按照某一种次序分配资源，并且依次地运行完毕，这种进程序列{ P1 ，P2 …Pn}就是安全序列。如果存在这样一个安全序列，则系统是安全的。
  
  安全状态不是死锁状态，死锁状态是非安全状态。然而，不是所有的非安全状态都是死锁，非安全状态只是可能产生死锁。
  
  对于安全状态的死锁避免算法，我们可以规定，当有进程申请一个可用资源时，系统应该明确，这一资源申请后系统应该仍然处于安全状态，这样才能完成申请，否则，进程应该等待。
  
### 7.4.3 资源分配图算法

  我们引入需求边：
  * 需求边：Pi->Rj，这种边表示进程Pi可能在某个时刻申请Rj。类似于申请边，但是用虚线表示。当进程Pi->Rj时，需求边成为了申请边。类似，当Rj->Pi时，分配边成为了需求边。
  
  现在假设Pi申请Rj。只有在申请边变成分配边的时候，并且资源分配图不会成环，才会允许申请。
  
### 7.4.4 银行家算法
  对于每种资源有多个实例，资源分配图就不适用了。
  
  为了实现银行家算法，必须在系统中设置四个数据结构，分别描述可利用资源，每个进程的最大需求，进程现在分配的每种资源的数量，每个进程还需要的资源数量。n为进程数量，m为资源的种类数。
  
  * Available：长度为m的向量，表示每种资源可用的实例数量。Avaiable[j]=k表示资源Rj还有k个可用。
  
  * Max：n*m矩阵，定义每个进程的最大需求。Max[i][j]=k表示进程Pi最大申请Rjk个实例。
  
  * Allocation：n*m矩阵，allocation[i][j]=k表示Pi现在分配了Rj的k个实例。  
  
  * Need：n*m矩阵，Need[i][j]=k表示Pi还需要k个Rj。
  
  注意，Max[I][J]=ALLOCATION[I][J]+NEED[I][J]。

# 7.5 死锁检测
### 等待图

###     银行家动态算法

# 7.6 死锁恢复
### 7.6.1 进程终止
  * 终止所有死锁进程
  
  * 一次终止一个，直到死锁解决
  
### 7.6.2 资源抢占
  不断抢占一些资源给其他进程使用，打破循环。
  
  * 选择牺牲进程：抢占哪些进程的资源
  
  * 回滚
  
  * 防止饥饿
    
  
   
 