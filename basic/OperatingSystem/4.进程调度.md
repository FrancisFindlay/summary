# 进程调度

# 5.1 基本概念
  
  对于不同类型进程对CPU的使用情况，应该区分不同进程使用CPU的优先级。
  
# 5.1.1 CPU 调度程序

  操作系统采用短期调度程序来从内存中选择将被CPU执行的进程。
  
  调度程序需要完成的功能包括
   
   * 切换上下文
   
   * 切换模式
   
   * 跳转到用户程序的某个模块
  
# 5.1.2 抢占调度
  
  需要进行CPU调度的进程有
   
   
  * 一个进程从运行态切换到等待态，如IO请求，wait（）的调用
  * 一个进程从运行态切换到就绪态，如中断的出现
  * 一个进程从等待切换到就绪，如IO完成
  * 一个进程终止时
  
  抢占：进程调度可以发生在上面任意情况
  
  非抢占：进程调度只能发生在1 4两种情况     
  
# 5.2 调度准则

  * CPU使用率：应该让CPU尽可能忙碌，减少空闲时间。
  
  * 吞吐率：应该让CPU尽可能多完成进程。
  
  * 周转时间：从提交进程到进程完成的时间，包括等待进入内存，在就绪队列中等待，CPU执行以及IO的总时间。
  
  * 响应时间：从提交请求到第一次响应的时间。
  
# 5.3 调度算法

# 5.3.1 FCFS 先来先服务
  先请求CPU的进程先被CPU执行，往往平均等待时间长。另外，FCFS是非抢占式的。
  
  FCFS不利用短作业，利于长作业。
  
# 5.3.2 SJF 最短作业优先调度 
  具有最短CPU执行时间的进程优先调度。SJF是平均等待时间最短的调度算法。
  
  问题是如何知道下次CPU执行需要花费多长时间。
  
  SJF可以是抢占和非抢占的，当新进程具有更短执行时间时，可以发生抢占行为。
  
# 5.3.3 PS 优先级调度
  可以指定一个评价算法来指定进程的优先级，最高优先级先执行。可以是抢占，也可以是非抢占的。
  
  主要问题是饥饿问题，低优先级的进程可能永远无法执行。可以通过老化算法进行解决，低优先级的进程定长时间可以晋升为高优先级进程。
  
# 5.3.4 RR 轮转调度
  通过抢占和时间片轮转来实现并发执行。对于超时进程执行中断。
  
  主要问题是平均等待时间长。
  
# 5.3.5 多级队列调度
  设置多个单独队列，根据进程的属性分配到不同的队列，每个队列执行不同的调度算法。
  
  另外，队列之间也应该设置优先级，高优先级队列始终比低优先级队列先得到执行。
        
# 5.3.6 多级反馈队列调度

  在多级队列调度的基础上，实现进程在队列之间的迁移。具体根据不同的迁移算法进行讨论，比如，根据执行时间定义三个队列，队列对时间要求逐渐增
  大。进程首先分配到high queue，如果在1-8ms没有执行完成，触发中断，并且把进程迁移到mid queue，依次类推。
  
# 5.4 线程调度
  内核级线程通过操作系统角度，用户线程通过线程库调度。
  
# 5.5 多处理器调度

  ASMP，对于多处理器系统，通常独立分配一个处理器执行调度分配任务，其他的处理器执行其他的工作进程。
              
  另外，还可以通过SMP（对称多处理）实现，每个处理器独立执行调度。             
  
# 5.5.2 处理器亲和性
  由于缓存的无效以及重新填充的成本太高，SMP系统通常避免将一个进程转移到另外的处理器，而是试图让一个进程运行在同一个处理器上。
  
  当一个操作系统仅仅是试图让一个进程保持在同一个处理器上，称之为软亲和力。但也可能实现转移。
  
  当操作系统明确要求进程保持在同一处理器，就称之为硬亲和力。Linux实现软亲和，但可以通过sched_setaffinity()支持硬亲和。  
  
  
# 5.5.3 负载均衡
  对于SMP，重要的是保证所有处理器的负载相当，避免部分处理器处于空闲而其他处理器处于高负载状态。
  
  通常有两种实现方法,
  
  * 推迁移：负载高的处理器将任务分配给低负载处理器。
  
  * 拉迁移：负载低的处理器主动请求负载高的处理器分配任务。
  
  
# 5.6 CPU调度
  * 软实时系统：只保证特定进程优先调度，没有强制的时间要求。
  * 硬实时系统：一个任务必须在截止期限前完成或者中断。
# 5.6.1 最小化延迟
  * 事件延迟：从事件发生到事件服务的时间。
     
  * 中断延迟：从CPU收到中断到中断处理程序开始的时间。
  
  * 调度延迟：从停止一个进程到启动另一个进程的时间。
  
  事件延迟包括中断延迟和调度延迟。
  
# 5.6.2 优先级调度
  
# 5.6.3 单调速率调度
  
   单调速率调度采用抢占的优先级调度策略。低优先级进程正在运行并且高优先级可以运行时发生抢占。
   
   进程的优先级由进程的周期决定，周期越短，优先级越高。这种策略的理由是，更频繁需要CPU的任务得到更高的优先级。
   
   单调速率调度可以认为是最优调度。
   
# 5.6.4 最早截止期限优先调度
  根据截止期限动态分配优先级。当一个进程可以运行时，应该声明截止期限要求。截止期限越早，优先级越高。
  
  这种策略进程的优先级是动态变化的。
  
# 5.6.5 比例分享调度
  调度程序在所有进程分配T股，每个进程占据其中的N份。比例分享调度只选择请求股数小于可用股数的进程执行。  