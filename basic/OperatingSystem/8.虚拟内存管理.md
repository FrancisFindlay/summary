# 虚拟内存管理

# 9.1 请求调页
  
  * 请求调页：仅仅在需要时才把相应的页加载到内存，不会把进程所有的页都加载到内存中。
  
  操作系统实现了调页程序用来实现请求调页。
  
### 9.1.1 基本概念
  前面所说的有效位可以实现这一需求。当该位位有效时，页合法，并且在内存中。当该位为无效，该页非法，或者合法但是不在内存上。
  
  对于标记为无效的页的访问，会发生缺页错误。缺页错误的处理过程如下：
  
  * 陷入操作系统
  * 保存寄存器状态和进程状态
  * 确定中断为缺页错误
  * 检查页面引用是否合法，确定磁盘位置
  * 从磁盘读入到空闲帧
  * IO时，将CPU分配给其他进程
  * 收到IO中断
  * 保存其他进程的中断现场
  * 确认是否是调页的中断
  * 修正页表等信息
  * 等待CPU再次分配给本进程
  * 现场恢复，重新启动执行缺页中断的指令
  
  对于缺页错误，关键是缺页错误后重新启动任何指令的能力。一种解决方案是执行前访问两块的两端，如果发生缺页错误，那么在执行前就发生，并且进行调页。
  另外一种方案就是使用临时寄存器来保存覆盖位置的值，如果有缺页错误，那么就从寄存器写回到内存。重新执行指令。
  
  对于请求调页，缺页错误率是非常重要的。否则，有效访问时间会大幅下降，系统忙于调页，实际工作时间减少。
  
# 9.2 写时复制
  fork（）创建了一个父进程地址空间的副本，然而，考虑到有时候很多父进程地址空间的复制是没有必要的，这时候，可以采用写时复制。
  
  写时复制允许父进程和子进程共享相同的页，但当遇到一个进程写入时，就创建子进程的副本。
  
  vfork()：不采用写时复制，子进程对父进程的修改是可见的，应该谨慎使用，当不进行写时或者写对父进程没有影响时，可以使用vfork（）。
  
# 9.3 页面置换
  在多道程序运行时，可能会过度分配内存。用户进程正在执行时，可能发生缺页错误，操作系统确定了所需要页对应的物理位置，但是却发现帧列表没有可用的空闲帧，所有内存都在使用。
  这时候，就需要页面置换。
 
### 9.3.1 基本页面置换
  如果没有空闲帧，操作系统就查找当前不在使用的一个帧，并释放它，可以这样来释放一个帧：将内容写到磁盘，然后修改页表表示其无效。现在，就可以使用空闲帧了。
  
  在这个过程中，需要调出和调入两次操作。我们可以使用脏位来避免，对于从来没有被修改的页，就不做标记，替换时直接替换；对于修改过的页，做一次标记，只对修改过的页进行磁盘写入。
  
  实现请求调页的两个问题是帧分配算法和页面置换算法。多道程序运行时，必须决定为每个进程分配多少帧，在需要页面置换时，替换哪些帧。对于置换算法，通常采用缺页错误率最低的算法。
  
  * 引用串：针对特定内存引用串，运行某个置换算法，并计算缺页错误数量，内存引用的串称为引用串。
  
  例如，0100，0432，0101，0601，0101，0103，0104...这样的串，每个页面为100B，那么可以写为：
  
  1,4,1,6,1...
  
### 9.3.2 FIFO页面置换
  当必须置换页面时，将选择最旧的页面进行置换。这时，就需要维护一个FIFO队列，管理所有的内存页面。
  
  FIFO易于实现，但是性能不够理想。它可能置换掉非常经常使用的页。另外，对于FIFO，部分特殊的引用串，可能存在分配帧增多，缺页错误率却上升的问题，我们称为Belady异常。
  
### 9.3.3 最优页面置换 OPT
  对于一个引用串，总是替换最长时间内不会被再次使用的页。这样，我们确保缺页错误率是最低的，并且不会有BeLady异常。但是，如何知道页在未来的使用情况是一个问题，因此，最优算法只有比较意义，难以实现。
  
### 9.3.4 LRU页面置换
  总是替换最长时间没有使用的页。LRU将每个页面与它上次使用的时间关联起来，当需要替换时，替换最长时间没使用的页。
  
  实现方式：
  
  * 计数器：每个页表条目都维护一个使用时间域，并为CPU添加逻辑时钟。这样，我们就知道了每个页面在什么时候使用过。这个方法需要搜索页面以查找LRU页面，并且每次内存访问都要写到内存（页表）。
  
  * 堆栈：采用页码堆栈，每次页被使用，就移到顶部。因为必须从堆栈的中间删除条目，所以最好通过使用双向链表进行实现。
  
  LRU不会有Belady异常。但每次内存引用，都需要更新时钟或者堆栈，如果每次引用都采用中断，会使内存引用非常慢，因此，也是不可能实现的。
  
### 9.3.5 近似LRU算法
  LRU难于实现，但很多系统都通过引用位给与一定的支持，每当页面被引用，它的引用位就被硬件置位。页表的每个条目都有一个引用位，最初，所有引用位都为0。
  
  * 额外引用位算法：为内存中页表的每个条目维护一个8位的计数器。每次页面的引用位被引用，就把引用位的值赋给计数器的最高位，并丢弃最低位。这样，具有最小编号的页就是最不经常使用的页，被替换。
  
  * 第二次机会算法：当引用位为0时，直接替换；当引用位为1时，给予第二次机会，引用位被设置为1。最坏情况下，所有位都为1，这时候，就退化为FIFO算法。
  
  * 增强型第二次机会算法：通过设置两个位，引用位和修改位（x，y）。对于修改过的页给予更高优先级，减少IO。
  
    * （0，0）：表示没有使用且没有修改，最佳替换。
    
    * （0，1）：没有使用，但是修改过了。不太好的替换。
    
    * （1，0）：最近使用过但是修改，可能很快再次使用。
    
    * （1，1）：最近使用过而且修改过。
    
  
  
### 9.3.6 基于计数的页面置换
  
  * LFU：最不经常使用算法，要求置换使用次数最少的页。然而，可能出现计数大但是不再使用的情况，可以定期右移解决。

  * MFU：假设最小计数的页可能是最可能使用的。
  
  这两种算法都不经常使用，原因是难于实现，并且不接近OPT置换。
### 9.3.7 页面缓冲算法
  除了特定的页面置换算法，还可以保留一个页面缓冲池。
  
  当缺页发生时，会像以前一样牺牲一个帧。然后，读到需要的帧就直接放入缓冲池的空闲帧，这样，就不需要等待页面写出后才能使用帧了。而当页面被写出后，原来的帧加入缓冲池。

# 9.4 帧分配
  另外的问题是，一个进程应该得到多少帧合适？
  
    
### 9.4.1 帧的最小数
  分配至少数量的帧的一个原因涉及性能。当分配过少时，缺页错误率增加，运行性能下降。但是，如果在执行指令前发生缺页错误，应该重启指令。因此，必须有足够的帧来容纳单个指令可以引用的所有不同的页面。
  
  最小帧的分配和计算机体系结构有关系，最大帧的数量由内存决定。
  
### 9.4.2 平均分配
  n个进程分配m个帧最容易实现的是，给每个进程一个平均值m/n帧。余数的帧作为缓冲池。但是，这样对于小容量进程有严重的内部碎片，因此，可以使用比例分配进行。
  
### 9.4.3 全局分配和局部分配
  
  * 全局置换：允许一个进程从所有帧集合中选择一个置换帧，而不考虑该帧是否已经分配给其他进程。
  
  * 局部置换：只能从自己分配的帧进行页面置换。
  
  全局置换对于区分优先级的系统有很好的应用，高优先级可以抢占低优先级进程的帧。但是，全局置换的问题是，一个进程的缺页率不能由自己控制了，会造成执行时间差别非常大的情况。
  
  而局部置换只由进程本身决定缺页率。但是，由于不能使用其他进程的帧，容易造成阻塞。因此，全局置换是更好的实现。
  
# 9.5 系统抖动
  进程没有足够帧分配时，需要置换经常使用的帧。依次，系统忙于页面置换，当系统的调页时间大于执行时间，就发生了系统抖动。
  
### 9.5.1 系统抖动的原因
  操作系统监视CPU利用率，当CPU利用率太低，增加多道程序。采用全局置换时，假设进程需要进行页面置换，此时从其他进程获得帧。然而，这些进程也需要这些帧，他们就从其他进程获得。这些缺页错误必须使用调页程序进行调整，这时候，CPU利用率降低。
  CPU调度程序看到CPU利用率降低，这时候，进而增加多道程序。结果，系统忙于调页，而任务没有进度。
  
  通过局部置换算法或者优先级置换算法可以限制系统抖动。
  
# 9.6 内存映射文件
  系统调用的read（），write（），open（）都是对磁盘的操作。每个文件访问都需要经过系统调用和磁盘。虚拟内存允许将磁盘映射到一个或者多个内存页面，最初，文件访问进行请求调页，从而产生缺页错误，然后，文件被读到内存，以后，该文件的读取就按照内存访问处理。
  
  
  
  
# 9.7 分配内核内存 
  分配内核内核和用户内存的不同。
  
### 9.7.1 伙伴系统
  伙伴系统从物理连续的内存上分配，采用2的幂分配器满足需要的内存。请求单元的大小总是比其大的2的n次幂。
  
  内核请求17K的内存空间，伙伴系统会为其分配32K。伙伴系统的优点在于可以和其他伙伴合成更大的块，缺点也很明显，内部碎片过大。

### 9.7.2 slab分配
  不会产生内存碎片。
  
# 9.8 其他问题

### 9.8.1 预调页面

  可以提前加载所有需要的页进入内存。取决于代价的大小。
  
### 9.8.2 页面的大小
  页面的大小都是2的N次幂。分配的页面过大，容易造成碎片，过小，IO就变得频繁，影响性能。         